\documentstyle[12pt,fullpage]{article}

\newcommand{\putfig}[3]%
{\begin{figure}%
\centerline{%
\psfig{figure=#1.ps,width=#3}}%
\caption{#2}%
\label{fig:#1}%
\end{figure}}

\input{psfig}

\begin{document}

\begin{figure*}[t]
\begin{center}
{\LARGE\bf A Quick Introduction to C++}

\vspace{3.0ex}

{\Large Tom Anderson}
\end{center}
\end{figure*}

\renewcommand{\thefootnote}{\fnsymbol{footnote}}

\footnotetext{This article is based on an earlier version written by Wayne Christopher.}

\renewcommand{\thefootnote}{}
\renewcommand{\thefootnote}{\arabic{footnote}}

\begin{quote}
``If programming in Pascal is like being put in a straightjacket,
then programming in C is like playing with knives, and programming
in C++ is like juggling chainsaws.'' \\ \hbox{} \hfill Anonymous.
\end{quote}

\section{Introduction}

This note introduces some simple C++ concepts and outlines a
subset of C++ that is easier to learn and use than
the full language.  Although we originally wrote this note for
explaining the C++ used in the Nachos project, I believe it is 
useful to anyone learning C++.
I assume that you are already somewhat familiar with C concepts
like procedures, for loops, and pointers; these are pretty easy
to pick up from reading Kernighan and Ritchie's ``The C Programming 
Language.''

I should admit up front that I am quite opinionated about C++, if
that isn't obvious already.
I know several C++ purists (an oxymoron perhaps?) who violently
disagree with some of
the prescriptions contained here; most of the objections are of
the form, ``How could you have possibly left out feature X?''
However, I've found from teaching C++ to nearly 1000 undergrads
over the past several years that the subset of C++ described here is
pretty easy to learn, taking only a day or so for most students 
to get started.

The basic premise of this note is that while object-oriented
programming is a useful way to simplify programs, C++ is a wildly
over-complicated
language, with a host of features that only very, very rarely find a
legitimate use.  It's not too far off the mark to say that C++ includes
every programming language feature ever imagined, and more.
The natural tendency when faced with a new language feature
is to try to use it, but in C++ this approach leads to disaster.

Thus, we need to carefully distinguish between (i) those concepts 
that are fundamental (e.g., classes, member functions, constructors)
-- ones that everyone should know and use, (ii) those that are sometimes 
but rarely useful (e.g., single inheritance, templates) -- ones that
beginner programmers should be able to recognize (in case they run across
them) but avoid using in their own programs, at least for a while,
and (iii) those that are just a bad idea and should be avoided like
the plague (e.g., multiple inheritance, exceptions, overloading,
references, etc).

Of course, all the items in this last category have their proponents,
and I will admit that, like the hated goto, it is possible to
construct cases when the program would be simpler using a goto or
multiple inheritance.  However, it is
my belief that most programmers will never encounter such cases,
and even if you do, you will be much more likely to misuse the 
feature than properly apply it.
For example, I seriously doubt an undergraduate would need any of 
the features listed under (iii) for any course project (at least
at Berkeley this is true).  And if you find yourself wanting to use 
a feature like multiple inheritance, then, my advice is to fully 
implement your program both with and without the feature, and choose 
whichever is simpler.  Sure, this takes more effort, but
pretty soon you'll know from experience when a feature is useful and when
it isn't, and you'll be able to skip the dual implementation.

A really good way to learn a language is to read clear programs in that
language.  I have tried to make the Nachos code as readable as possible;
it is written in the subset of C++ described in this note.
It is a good idea to look over the first assignment as you read this
introduction.  Of course, your TA's will answer any questions you may
have.

You should not need a book on C++ to do the Nachos assignments, but if 
you are curious, there is a large selection of C++ books
at Cody's and other technical bookstores. (My wife quips that C++ was
invented to make researchers at Bell Labs rich from writing
``How to Program in C++'' books.)   Most new software development
these days is being done in C++, so it is a pretty good bet you'll 
run across it in the future.  I use Stroustrup's "The C++
Programming Language" as a reference manual, although other 
books may be more readable.  I would also recommend Scott Meyer's
``Effective C++'' for people just beginning to learn the language,
and Coplien's ``Advanced C++'' once you've been programming in C++ 
for a couple years and are familiar with the language basics.
Also, C++ is continually evolving, so be careful to buy books that describe
the latest version (currently 3.0, I think!).

\section{C in C++}

To a large extent, C++ is a superset of C, and most carefully written
ANSI C will compile as C++.  There are a few major caveats though:

\begin{enumerate}

\item All functions must be declared before they are used, rather than
defaulting to type {\tt int}.

\item All function declarations and definition headers must use
new-style declarations, e.g.,

\begin{verbatim}
extern int foo(int a, char* b);
\end{verbatim}

The form {\tt extern int foo();} means that {\tt foo} takes {\it no}
arguments, rather than arguments of an unspecified type and number.
In fact, some advise using a C++ compiler even
on normal C code, because it will catch errors like misused functions that
a normal C compiler will let slide.

\item If you need to link C object files together with C++, when you
declare the C functions for the C++ files, they must be done like this:

\begin{verbatim}
extern "C" int foo(int a, char* b);
\end{verbatim}

Otherwise the C++ compiler will alter the name in a strange manner.

\item There are a number of new keywords, which you may not use as
identifiers --- some common ones are {\tt new}, {\tt delete}, {\tt
const}, and {\tt class}.

\end{enumerate}

\section{Basic Concepts}

Before giving examples of C++ features, I will first go over some of
the basic concepts of object-oriented languages.  If this discussion
at first seems a bit obscure, it will become clearer when we get
to some examples.

\begin{enumerate}

\item {\bf Classes and objects}.  A class is similar to a C {\em structure},
except that the definition of the data structure, {\em and} all of the 
functions that operate on the data structure are grouped together
in one place.  An {\em object} is an instance of a class (an instance
of the data structure); objects share the same functions with other objects
of the same class, but each object (each instance) has its own copy of 
the data structure.  A class thus defines two aspects of the objects: 
the {\em data} they contain, and the {\em behavior} they have.

\item {\bf Member functions}.  These are functions which are
considered part of the object and are declared in the class
definition.  They are often referred to as {\em methods} of the class.
In addition to member functions, a class's behavior is also defined
by:
\begin{enumerate}
\item What to do when you create a new object (the {\bf constructor}
for that object) -- in other words, initialize the object's data.
\item What to do when you delete an object (the {\bf destructor} for
that object).
\end{enumerate}

\item {\bf Private vs. public members}.  A public member of a class is
one that can be read or written by anybody, in the case of a data
member, or called by anybody, in the case of a member function.  A
private member can only be read, written, or called by a member
function of that class.
\end{enumerate}

Classes are used for two main reasons: (1) it makes it much easier to
organize your programs if you can group together data with the
functions that manipulate that data, and (2) the use of private
members makes it possible to do {\em information hiding}, so that you
can be more confident about the way information flows in your
programs.

\subsection{Classes}

C++ classes are similar to C structures in many ways.  In fact, a C++
struct is really a class that has only public data members.
In the following explanation of how classes work, we will use a stack
class as an example.

\begin{enumerate}
\item {\bf Member functions.}   Here is a (partial) example of a class
with a member function and some data members:
\begin{verbatim}
class Stack {
  public:
    void Push(int value); // Push an integer, checking for overflow.
    int top;          // Index of the top of the stack.
    int stack[10];    // The elements of the stack.
};

void
Stack::Push(int value) {
    ASSERT(top < 10);		// stack should never overflow
    stack[top++] = value;
}
\end{verbatim}

This class has two data members, {\tt top} and {\tt stack}, and one
member function, {\tt Push}.  
The notation {\em class}::{\em function} denotes the
{\em function} member of the class {\em class}.  (In the style we use,
most function names are capitalized.)  The function is defined beneath
it.  

As an aside, note that we use a call to {\tt ASSERT} to check that 
the stack hasn't overflowed; ASSERT drops into the debugger if the condition
is false.  It is an extremely good idea for you to use ASSERT
statements liberally throughout your code to document assumptions
made by your implementation.  Better to catch errors automatically
via ASSERTs than to let them go by and have your program overwrite 
random locations.  

In actual usage, the definition of {\tt class Stack} would typically
go in the file {\tt stack.h} and the definitions of the member
functions, like {\tt Stack::Push}, would go in the file {\tt
stack.cc}.

If we have a pointer to a {\tt Stack} object called {\tt s}, we can
access the {\tt top} element as {\tt s->top}, just as in C.  However,
in C++ we can also call the member function using the following syntax:

\begin{verbatim}
    s->Push(17);
\end{verbatim}

Of course, as in C, {\tt s} must point to a valid {\tt Stack} object.

Inside a member function, one may refer to the members of the class
by their names alone.  In other words, the class definition
creates a scope that includes the member (function and data) definitions.

Note that if you are inside a member function, you can get a pointer
to the object you were called on by using the variable {\tt this}.
If you want to call another member function on the same object, you
do not need to use the {\tt this} pointer, however.  Let's extend the Stack
example to illustrate this by adding a {\tt Full()} function.

\begin{verbatim}
class Stack {
  public:
    void Push(int value); // Push an integer, checking for overflow.
    bool Full();       // Returns TRUE if the stack is full, FALSE otherwise.
    int top;          // Index of the lowest unused position.
    int stack[10];    // A pointer to an array that holds the contents.
};
\end{verbatim}
\newpage
\begin{verbatim}
bool
Stack::Full() {
    return (top == 10);
}
\end{verbatim}

Now we can rewrite {\tt Push} this way:

\begin{verbatim}
void
Stack::Push(int value) {
    ASSERT(!Full());
    stack[top++] = value;
}
\end{verbatim}

We could have also written the ASSERT:

\begin{verbatim}
    ASSERT(!(this->Full());
\end{verbatim}

but in a member function, the \verb+this->+ is implicit.

The purpose of member functions is to encapsulate the functionality of
a type of object along with the data that the object contains.  A
member function does not take up space in an object of the class.

\item {\bf Private members.}  One can declare some
members of a class to be {\it private}, which are hidden to all but
the member functions of that class, and some to be {\it public}, which
are visible and accessible to everybody.  Both data and function members
can be either public or private.

In our stack example, note that once we have the {\tt Full()}
function, we really don't need to look at the {\tt top} or {\tt stack}
members outside of the class -- in fact, we'd rather that users of the Stack
abstraction {\em not} know about its internal implementation, in case
we change it.  Thus we can rewrite the class as follows:

\begin{verbatim}
class Stack {
  public:
    void Push(int value); // Push an integer, checking for overflow.
    bool Full();       // Returns TRUE if the stack is full, FALSE otherwise.
  private:
    int top;          // Index of the top of the stack.
    int stack[10];    // The elements of the stack.
};
\end{verbatim}

Before, given a pointer to a {\tt Stack} object, say {\tt s}, any part
of the program could access {\tt s->top}, in potentially bad ways.
Now, since the {\tt top} member is private, only a member function,
such as {\tt Full()}, can access it.  If any other part of the
program attempts to use {\tt s->top} the compiler will report an error.

You can have alternating {\tt public:} and {\tt private:} sections in
a class.  Before you specify either of these, class members are
private, thus the above example could have been written:

\begin{verbatim}
class Stack {
    int top;          // Index of the top of the stack.
    int stack[10];    // The elements of the stack.
  public:
    void Push(int value); // Push an integer, checking for overflow.
    bool Full();       // Returns TRUE if the stack is full, FALSE otherwise.
};
\end{verbatim}

Which form you prefer is a matter of style, but it's usually best
to be explicit, so that it is obvious what is intended.  In Nachos,
we make everything explicit.

What is not a matter of style: {\bf all data members of a class 
should be private.}  All operations on data should be via that
class' member functions.  Keeping data private adds to the modularity 
of the system, since you can redefine how the data members are stored 
without changing how you access them.

\item {\bf Constructors and the operator new.}  In C, in
order to create a new object of type {\tt Stack}, one might write:

\begin{verbatim}
    struct Stack *s = (struct Stack *) malloc(sizeof (struct Stack));
    InitStack(s, 17);
\end{verbatim}

The {\tt InitStack()} function might take the second argument as the
size of the stack to create, and use {\tt malloc()} again to get an
array of 17 integers.

The way this is done in C++ is as follows:

\begin{verbatim}
    Stack *s = new Stack(17);
\end{verbatim}

The {\tt new} function takes the place of {\tt malloc()}.  To
specify how the object should be initialized, one declares a {\it
constructor} function as a member of the class, with the name of the
function being the same as the class name:

\begin{verbatim}
class Stack {
  public:
    Stack(int sz);    // Constructor:  initialize variables, allocate space.
    void Push(int value); // Push an integer, checking for overflow.
    bool Full();       // Returns TRUE if the stack is full, FALSE otherwise.
  private:
    int size;         // The maximum capacity of the stack.
    int top;          // Index of the lowest unused position.
    int* stack;       // A pointer to an array that holds the contents.
};

Stack::Stack(int sz) {
    size = sz;
    top = 0;
    stack = new int[size];   // Let's get an array of integers.
}
\end{verbatim}

There are a few things going on here, so we will describe them one at
a time.

The {\tt new} operator automatically creates (i.e. allocates) the object
and then calls the constructor function for the new object.
This same sequence happens even if, for instance, you declare an object
as an automatic variable inside a function or block -- the compiler allocates
space for the object on the stack, and calls the constructor function on it.

In this example, we create two stacks of different sizes, one
by declaring it as an automatic variable, and one by using {\tt new}.

\begin{verbatim}
void
test() {
    Stack s1(17);
    Stack* s2 = new Stack(23);
}
\end{verbatim}

Note there are two ways of providing arguments to constructors: with
{\tt new}, you put the argument list after the class name, and with
automatic or global variables, you put them after the variable name.

It is crucial that you {\bf always} define a constructor
for every class you define, and that the constructor initialize
{\bf every} data member of the class.  If you don't define 
your own constructor, the compiler will automatically define
one for you, and believe me, it won't do what you want
(``the unhelpful compiler'').
The data members will be initialized to random, unrepeatable
values, and while your program may work anyway, it might not
the next time you recompile (or vice versa!).

As with normal C variables, variables declared inside a function
are deallocated automatically when the function returns; for  
example, the {\tt s1} object is deallocated when {\tt test}
returns.  Data allocated with {\tt new} (such as {\tt s2}) is 
stored on the heap, however, and remains after the function returns;
heap data must be explicitly disposed of using {\tt delete}, described below.  

The {\tt new} operator can also be used to allocate arrays, illustrated
above in allocating an array of {\tt ints}, of dimension {\tt size}:

\begin{verbatim}
    stack = new int[size];
\end{verbatim}

Note that you can use {\tt new} and {\tt delete} (described below)
with built-in types like {\tt int} and {\tt char} as well as with
class objects like {\tt Stack}.

\item {\bf Destructors and the operator delete.}  Just as {\tt new} is the
replacement for {\tt malloc()}, the replacement for {\tt free()} is
{\tt delete}.  To get rid of the {\tt Stack} object we allocated
above with {\tt new}, one can do:

\begin{verbatim}
    delete s2;
\end{verbatim}

This will deallocate the object, but first it will call the
{\it destructor} for the {\tt Stack} class, if there is one.  This
destructor is a member function of {\tt Stack} called {\tt {\verb^~^}Stack()}:

\begin{verbatim}
class Stack {
  public:
    Stack(int sz);    // Constructor:  initialize variables, allocate space.
    ~Stack();         // Destructor:   deallocate space allocated above.
    void Push(int value); // Push an integer, checking for overflow.
    bool Full();      // Returns TRUE if the stack is full, FALSE otherwise.
  private:
    int size;         // The maximum capacity of the stack.
    int top;          // Index of the lowest unused position.
    int* stack;       // A pointer to an array that holds the contents.
};

Stack::~Stack() {
    delete [] stack;  // delete an array of integers
}
\end{verbatim}

The destructor has the job of deallocating the data the constructor
allocated.  Many classes won't need destructors, and some will use
them to close files and otherwise clean up after themselves.

The destructor for an object is called when the object is deallocated.
If the object was created with {\tt new}, then you must call
{\tt delete} on the object, or else the object will continue
to occupy space until the program is over -- this is called
``a memory leak.''  Memory leaks are bad things -- although virtual
memory is supposed to be unlimited, you can in fact run out of it --
and so you should be careful to {\bf always} delete what you allocate.
Of course, it is even worse to call {\tt delete} too early --
{\tt delete} calls the destructor and puts the space back on the heap 
for later re-use.  If you are still using the object, you will
get random and non-repeatable results that will be very difficult
to debug.  In my experience, using data that has already been deleted 
is major source of hard-to-locate bugs in student (and professional)
programs, so hey, be careful out there!

If the object is an automatic, allocated on the execution stack
of a function, the destructor will be called and the space deallocated when
the function returns; in the {\tt test()} example above, {\tt s1}
will be deallocated when {\tt test()} returns, without you having to
do anything.

In Nachos, we always explicitly allocate and deallocate objects with 
{\tt new} and {\tt delete}, to make it clear when the constructor and
destructor is being called.  For example, if an object contains another 
object as a member variable, we use
{\tt new} to explicitly allocated and initialize the member variable,
instead of implicitly allocating it as part of the containing object.
C++ has strange, non-intuitive rules for the order in which the 
constructors and destructors are called when you implicitly allocate 
and deallocate objects.  In practice, although simpler, explicit allocation 
is slightly slower and it makes it more likely that you will forget 
to deallocate an object (a bad thing!), and so some would disagree with 
this approach.

When you deallocate an array, you have to tell the compiler that
you are deallocating an array, as opposed to a single element in the array.
Hence to delete the array of integers in {\tt Stack::{\verb^~^}Stack}:

\begin{verbatim}
    delete [] stack;
\end{verbatim}

\end{enumerate}

\subsection{Other Basic C++ Features}

Here are a few other C++ features that are useful to know.

\begin{enumerate}

\item When you define a {\tt class Stack}, the name {\tt Stack} becomes
usable as a type name as if created with {\tt typedef}.  The same is
true for {\tt enum}s.

\item You can define functions inside of a {\tt class} definition,
whereupon they become {\it inline functions}, which are expanded in
the body of the function where they are used.  The rule of thumb to
follow is to only consider inlining one-line functions, and even then 
do so rarely.  

As an example, we could make the {\tt Full} routine an inline.

\begin{verbatim}
class Stack {
   ...
   bool Full() { return (top == size); };
   ...
};
\end{verbatim}

There are two motivations for inlines: convenience
and performance.  If overused, inlines can make your code more confusing,
because the implementation for an object is no longer in one place, 
but spread between the {\tt .h} and {\tt .c} files.  Inlines can sometimes
speed up your code (by avoiding the overhead of a procedure call), but 
that shouldn't be your principal concern as a student (rather, at least to 
begin with, you should be most concerned with writing code that is simple 
and bug free).  Not to mention that inlining sometimes slows down a program,
since the object code for the function is duplicated wherever the function 
is called, potentially hurting cache performance.

\item Inside a function body, you can declare some variables, execute
some statements, and then declare more variables.  This can make code
a lot more readable.  In fact, you can even write things like:

\begin{verbatim}
for (int i = 0; i < 10; i++) ;
\end{verbatim}

Depending on your compiler, however, the variable {\tt i} may still visible
after the end of the {\tt for}
loop, however, which is not what one might expect or desire.

\item Comments can begin with the characters \verb+//+ and extend to
the end of the line.  These are usually more handy than the
\verb+/* */+ style of comments.

\item C++ provides some new opportunities to use the 
{\tt const} keyword from ANSI C.  The basic idea of {\tt const}
is to provide extra information to the compiler about how a variable
or function is used, to allow it to flag an error if it is being 
used improperly.  You should always look for ways to get the compiler 
to catch bugs for you.  After all, which takes less time?  Fixing
a compiler-flagged error, or chasing down the same bug using gdb?  

For example, you can declare that a member function only reads the 
member data, and never modifies the object:

\begin{verbatim}
class Stack {
   ...
   bool Full() const;  // Full() never modifies member data
   ...
};
\end{verbatim}

As in C, you can use {\tt const} to declare that a variable is never 
modified:

\begin{verbatim}
    const int InitialHashTableSize = 8;
\end{verbatim}

This is {\em much} better than using {\tt \#define} for constants,
since the above is type-checked.

\item Input/output in C++ can be done with the {\tt >>} and {\tt <<}
operators and the objects {\tt cin} and {\tt cout}.  For example,
to write to {\tt stdout}:

\begin{verbatim}
    cout << "Hello world!  This is section " << 3 << "!";
\end{verbatim}

This is equivalent to the normal C code

\begin{verbatim}
    fprintf(stdout, "Hello world!  This is section %d!\n", 3);
\end{verbatim}

except that the C++ version is type-safe; with {\tt printf}, the
compiler won't complain if you try to print a floating point number
as an integer. In fact, you can use traditional {\tt printf} in a C++
program, but you will get bizarre behavior if you try to use both
{\tt printf} and {\tt <<} on the same stream.  Reading from {\tt stdin}
works the same way as writing to {\tt stdout}, except using the shift 
right operator instead of shift left.  
In order to read two integers from {\tt stdin}:

\begin{verbatim}
    int field1, field2;
    cin >> field1 >> field2;
        // equivalent to fscanf(stdin, "%d %d", &field1, &field2);
        // note that field1 and field2 are implicitly modified
\end{verbatim}

In fact, {\tt cin} and {\tt cout} are implemented as normal C++
objects, using operator overloading and reference parameters, but
(fortunately!) you don't need to understand either of those to be able
to do I/O in C++.
\end{enumerate}

\section{Advanced Concepts in C++: Dangerous but Occasionally Useful}

There are a few C++ features, namely (single) inheritance and templates,
which are easily abused, but can dramatically simplify an
implementation if used properly.  I describe the basic idea
behind these ``dangerous but useful'' features here, in case you 
run across them.  Feel free to skip this section -- it's long,
complex, and you can understand 99\% of the code in Nachos without
reading this section.

Up to this point, there really hasn't been any fundamental difference
between programming in C and in C++.  In fact, most experienced 
C programmers organize their functions into modules that relate
to a single data structure (a "class"), and often even use a naming 
convention which mimics C++, for example, naming routines 
{\tt StackFull()} and {\tt StackPush()}.  However, the features 
I'm about to describe {\em do} require a paradigm shift -- there
is no simple translation from them into a normal C program.
The benefit will be that, in some circumstances, you will be able to 
write generic code that works with multiple kinds of objects.

Nevertheless, I would advise a beginning C++ programmer against trying
to use these features, because you will almost
certainly misuse them.  It's possible (even easy!) to write completely 
inscrutable code using inheritance and/or templates.  Although
you might find it amusing to write code that is impossible for your 
graders to understand, I assure you they won't find it amusing at all,
and will return the favor when they assign grades.  In industry,
a high premium is placed on keeping code simple and readable. 
It's easy to write new code, but the real cost comes when
you try to keep it working, even as you add new features to it.

Nachos contains a few examples of the correct use of inheritance 
and templates, but realize that Nachos does {\em not} use them
everywhere.  In fact, if you get confused by this section, don't worry,
you don't need to use any of these features in order to do the Nachos
assignments.  I omit a whole bunch of details; if you find yourself
making widespread use of inheritance or templates, you should consult a C++
reference manual for the real scoop.  This is meant to
be just enough to get you started, and to help you identify when it would
be appropriate to use these features and thus learn more
about them!

\subsection{Inheritance}
Inheritance captures the idea that certain classes of objects are
related to each other in useful ways.  For example, lists
and sorted lists have quite similar behavior -- they both 
allow the user to insert, delete, and find elements that are
on the list.  There are two benefits to using inheritance:

\begin{enumerate}

\item You can write generic code that doesn't
care exactly which kind of object it is manipulating.  For
example, inheritance is widely used in windowing systems.
Everything on the screen (windows, scroll bars, titles, icons)
is its own object, but they all share a set of member functions
in common, such as a routine {\tt Repaint} to redraw the object
onto the screen.  This way, the code to repaint the entire screen 
can simply call the {\tt Repaint} function on every object on the screen.
The code that calls {\tt Repaint} doesn't need to know which
kinds of objects are on the screen, as long as each implements
{\tt Repaint}.

\item You can share pieces of an implementation between two
objects.  For example, if you were to implement both lists and 
sorted lists in C, you'd probably find yourself repeating code
in both places -- in fact, you might be really tempted to
only implement sorted lists, so that you only had to debug
one version.  Inheritance provides a way to re-use code
between nearly similar classes.  For example, given an implementation
of a list class, in C++ you can implement sorted lists by replacing
the insert member function -- the other functions, delete, isFull,
print, all remain the same.

\end{enumerate}

\subsubsection{Shared Behavior}

Let me use our Stack example to illustrate the first of these.
Our Stack implementation 
above could have been implemented with linked lists, instead of an array.
Any code using a Stack shouldn't
care which implementation is being used, except that the linked list
implementation can't overflow. (In fact, we could also change the
array implementation to handle overflow by automatically resizing
the array as items are pushed on the stack.)

To allow the two implementations to coexist, we first define an
{\em abstract} Stack, containing just the public member functions, 
but no data.

\begin{verbatim}
class Stack {
  public:
    Stack();
    virtual ~Stack();          // deallocate the stack
    virtual void Push(int value) = 0; 
                               // Push an integer, checking for overflow.
    virtual bool Full() = 0;   // Is the stack is full?
};

// For g++, need these even though no data to initialize.
Stack::Stack {}             
Stack::~Stack() {}
\end{verbatim}

The {\tt Stack} definition is called a {\em base class} or sometimes a {\em
superclass}.  We can then define two different {\em derived classes}, 
sometimes called {\em subclasses} which inherit behavior from the base
class.  (Of course, inheritance is recursive -- a derived class can in 
turn be a base class for yet another derived class, and so on.)
Note that I have prepended the functions in the base class is prepended 
with the keyword {\tt virtual}, to signify that they can be redefined by 
each of the two derived classes.  The virtual functions are
initialized to zero, to tell the compiler that those functions
must be defined by the derived classes.

Here's how we could declare the array-based and list-based
implementations of {\tt Stack}. The syntax {\tt : public Stack} signifies 
that both {\tt ArrayStack} and {\tt ListStack} are kinds 
of {\tt Stacks}, and share the same behavior as the base class.

\begin{verbatim}
class ArrayStack : public Stack {  // the same as in Section 2
  public:
    ArrayStack(int sz);   // Constructor:  initialize variables, allocate space.
    ~ArrayStack();        // Destructor:   deallocate space allocated above.
    void Push(int value); // Push an integer, checking for overflow.
    bool Full();     // Returns TRUE if the stack is full, FALSE otherwise.
  private:
    int size;        // The maximum capacity of the stack.
    int top;         // Index of the lowest unused position.
    int *stack;      // A pointer to an array that holds the contents.
};

class ListStack : public Stack {
  public:
    ListStack(); 
    ~ListStack();
    void Push(int value);
    bool Full();
  private:
    List *list;		// list of items pushed on the stack
};

ListStack::ListStack() { 
    list = new List;
}

ListStack::~ListStack() { 
    delete list; 
}
\end{verbatim}
\newpage
\begin{verbatim}
void ListStack::Push(int value) {
    list->Prepend(value); 
}

bool ListStack::Full() {
    return FALSE; 	// this stack never overflows!
}  
\end{verbatim}

The neat concept here is that I can assign pointers to instances of
{\tt ListStack} or {\tt ArrayStack} to a variable of type {\tt Stack}, and
then use them as if they were of the base type.

\begin{verbatim}
    Stack *s1 = new ListStack;
    Stack *s2 = new ArrayStack(17);

    if (!stack->Full())
        s1->Push(5);
    if (!s2->Full())
        s2->Push(6);

    delete s1;
    delete s2;
\end{verbatim}

The compiler automatically invokes {\tt ListStack} operations
for {\tt s1}, and {\tt ArrayStack} operations for {\tt s2};
this is done by creating a procedure table for each object,
where derived objects override the default entries in the table
defined by the base class.  To the code above, it invokes the
operations {\tt Full}, {\tt Push}, and {\tt delete} by indirection
through the procedure table, so that the code doesn't need to know
which kind of object it is.

In this example, since I never create an instance of the
abstract class {\tt Stack}, I do not need to {\em implement} its
functions.  This might seem a bit strange, but remember that
the derived classes are the various implementations of Stack,
and Stack serves only to reflect the shared behavior between
the different implementations.  

Also note that the destructor for {\tt Stack} is a virtual 
function but the constructor is not.  Clearly, when I create an
object, I have to know which kind of object it is, whether 
{\tt ArrayStack} or {\tt ListStack}.  The compiler 
makes sure that no one creates an instance of the abstract {\tt Stack} 
by mistake -- you cannot instantiate any class whose virtual 
functions are not completely defined (in other words, if any of 
its functions are set to zero in the class definition).

But when I deallocate an object, I may no longer know its exact
type.  In the above code, I want to call the destructor for the
derived object, even though the code only knows that I am deleting
an object of class {\tt Stack}.  If the destructor were not virtual,
then the compiler would invoke {\tt Stack}'s destructor, which is 
not at all what I want.  This is an easy mistake to make (I made
it in the first draft of this article!) -- if you don't define
a destructor for the abstract class, the compiler will define one 
for you implicitly (and by the way, it won't be virtual, since you
have a {\em really} unhelpful compiler).  The result for the
above code would be a memory leak, and who knows how you would 
figure that out!

\subsubsection{Shared Implementation}

What about sharing code, the other reason for inheritance? 
In C++, it is possible to use member functions
of a base class in its derived class.  (You can also share
data between a base class and derived classes, but this
is a bad idea for reasons I'll discuss later.)

Suppose that I wanted to add a new member function,
{\tt NumberPushed()}, to both implementations of {\tt Stack}.
The {\tt ArrayStack} class already keeps count of the number of
items on the stack, so I could duplicate that code in {\tt ListStack}.
Ideally, I'd like to be able to use the same code in both places.
With inheritance, we can move the counter into the 
{\tt Stack} class, and then invoke the base class operations
from the derived class to update the counter.

\begin{verbatim}
class Stack {
  public:
    virtual ~Stack();		// deallocate data
    virtual void Push(int value); // Push an integer, checking for overflow.
    virtual bool Full() = 0;	// return TRUE if full
    int NumPushed();	        // how many are currently on the stack?
  protected:
    Stack();			// initialize data
  private:
    int numPushed;
};

Stack::Stack() { 
    numPushed = 0; 
}

void Stack::Push(int value) { 
    numPushed++; 
}

int Stack::NumPushed() { 
    return numPushed; 
}
\end{verbatim}

We can then modify both {\tt ArrayStack} and {\tt ListStack}
to make use the new behavior of {\tt Stack}.  I'll only list
one of them here:

\begin{verbatim}
class ArrayStack : public Stack {
  public:
    ArrayStack(int sz);   
    ~ArrayStack();        
    void Push(int value); 
    bool Full();     
  private:
    int size;        // The maximum capacity of the stack.
    int *stack;      // A pointer to an array that holds the contents.
};

ArrayStack::ArrayStack(int sz) : Stack() { 
    size = sz;
    stack = new int[size];   // Let's get an array of integers.
}

void
ArrayStack::Push(int value) {
    ASSERT(!Full());
    stack[NumPushed()] = value;
    Stack::Push();	     // invoke base class to increment numPushed
}
\end{verbatim}

There are a few things to note:

\begin{enumerate}

\item The constructor for {\tt ArrayStack} needs to invoke the
constructor for {\tt Stack}, in order to initialize {\tt numPushed}.
It does that by adding {\tt : Stack()} to the first line in the constructor:

\begin{verbatim}
ArrayStack::ArrayStack(int sz) : Stack()
\end{verbatim}

The same thing applies to destructors.  There are special rules for which 
get called first -- the constructor/destructor for the base class or 
the constructor/destructor for the derived class.  All I should say is,
it's a bad idea to rely on whatever the rule is -- more generally, it is a 
bad idea to write code which requires the reader to consult a manual 
to tell whether or not the code works!

\item I introduced a new keyword, {\tt protected}, in the new definition
of {\tt Stack}.  For a base class, {\tt protected} signifies that those
member data and functions are accessible to classes derived (recursively)
from this class, but inaccessible to other classes.  In other words, protected
data is {\tt public} to derived classes, and {\tt private} to everyone else.
For example, we need {\tt Stack}'s constructor to be callable by 
{\tt ArrayStack} and {\tt ListStack}, but we don't want anyone
else to create instances of {\tt Stack}.  Hence, we make {\tt Stack}'s 
constructor a protected function.  In this case, this is not strictly
necessary since the compiler will complain if anyone tries to create an
instance of {\tt Stack} because {\tt Stack} still has an undefined virtual 
functions, {\tt Push}.  By defining {\tt Stack::Stack} as {\tt protected}, 
you are safe even if someone comes along later and defines {\tt Stack::Push}.

Note however that I made {\tt Stack}'s data member {\tt private}, not
{\tt protected}.  Although there is some debate on this point,
as a rule of thumb you should never allow one class to see directly
access the data in another, even among classes related
by inheritance.  Otherwise, if you ever change the implementation
of the base class, you will have to examine and change all the 
implementations of the derived classes, violating modularity.

\item The interface for a derived class automatically includes all
functions defined for its base class, without having to explicitly 
list them in the derived class.  Although we didn't define 
{\tt NumPushed()} in {\tt ArrayStack}, we can still call it for 
those objects:

\begin{verbatim}
    ArrayStack *s = new ArrayStack(17);

    ASSERT(s->NumPushed() == 0);	// should be initialized to 0
\end{verbatim}

\item Conversely, even though we have defined a routine {\tt Stack::Push()},
because it is declared as {\tt virtual}, if we invoke {\tt Push()} 
on an {\tt ArrayStack} object, we will get {\tt ArrayStack}'s version 
of {\tt Push}:

\begin{verbatim}
    Stack *s = new ArrayStack(17);

    if (!s->Full())		// ArrayStack::Full
        s->Push(5);		// ArrayStack::Push
\end{verbatim}

\item {\tt Stack::NumPushed()} is not {\tt virtual}.  That means 
that it cannot be re-defined by {\tt Stack}'s derived classes.
Some people believe that you should mark {\em all} functions
in a base class as {\tt virtual}; that way, if you later want to
implement a derived class that redefines a function, you don't have
to modify the base class to do so.

\item Member functions in a derived class can explicitly invoke 
public or protected functions in the base class, by the full
name of the function, {\tt Base::Function()}, as in:

\begin{verbatim}
void ArrayStack::Push(int value)
{
    ...
    Stack::Push();	     // invoke base class to increment numPushed
}
\end{verbatim}

Of course, if we just called {\tt Push()} here (without prepending 
{\tt Stack::}, the compiler would think we were referring 
to {\tt ArrayStack}'s {\tt Push()}, and so that would recurse,
which is not exactly what we had in mind here.

\end{enumerate}

Whew!  Inheritance in C++ involves lots and lots of details.
But it's real downside is that it tends to spread implementation 
details across multiple files -- if you have a deep inheritance 
tree, it can take some serious digging to figure out what code 
actually executes when a member function is invoked.

So the question to ask yourself before using inheritance is:
what's your goal?  Is it to write your programs with the
fewest number of characters possible?  If so, inheritance is
really useful, but so is changing all of your function and variable 
names to be one letter long -- "a", "b", "c" -- and once you
run out of lower case ones, start using upper case, then two character 
variable names: "XX XY XZ Ya ..." (I'm joking here.)
Needless to say, it is really easy to write unreadable code
using inheritance.  

So when is it a good idea to use inheritance and when should it be
avoided?  My rule of thumb is to only use it for representing 
{\em shared behavior} between objects, and to never use it for
representing {\em shared implementation}.  With C++, you can use 
inheritance for both concepts, but only the first will lead to
truly simpler implementations.

To illustrate the difference between shared behavior and shared
implementation, suppose you had a whole bunch of different kinds
of objects that you needed to put on lists.  For example, almost everything
in an operating system goes on a list of some sort: buffers, threads,
users, terminals, etc.

A very common approach to this problem (particularly among people new
to object-oriented programming) is to make every object inherit from
a single base class {\em Object}, which contains the forward and backward
pointers for the list.  But what if some object needs to go on multiple
lists?  The whole scheme breaks down, and it's because we tried to use
inheritance to share implementation (the code for the forward and backward
pointers) instead of to share behavior.  A much cleaner (although slightly
slower) approach would
be to define a list implementation that allocated forward/backward
pointers for each object that gets put on a list.

In sum, if two classes share at least some of the same member function
signatures -- that is, the same behavior, {\em and} if there's code that
only relies on the shared behavior, then there {\em may}
be a benefit to using inheritance.  In Nachos, locks don't inherit from
semaphores, even though locks are implemented using semaphores.  The
operations on semaphores and locks are different.  Instead, inheritance is
only used for various kinds of lists (sorted, keyed, etc.),
and for different implementations of the physical disk abstraction,
to reflect whether the disk has a track buffer, etc.  A disk is used
the same way whether or not it has a track buffer; the only difference is
in its performance characteristics.

\subsection{Templates}

Templates are another useful but dangerous concept in C++.
With templates, you can parameterize a class definition
with a {\em type}, to allow you to write generic type-independent
code.  For example, our {\tt Stack} implementation above only worked 
for pushing and popping {\em integers}; what if we wanted a stack 
of characters, or floats, or pointers, or some arbitrary data structure?

In C++, this is pretty easy to do using templates:

\begin{verbatim}
template <class T> 
class Stack {
  public:
    Stack(int sz);    // Constructor:  initialize variables, allocate space.
    ~Stack();         // Destructor:   deallocate space allocated above.
    void Push(T value); // Push an integer, checking for overflow.
    bool Full();      // Returns TRUE if the stack is full, FALSE otherwise.
  private:
    int size;         // The maximum capacity of the stack.
    int top;          // Index of the lowest unused position.
    T *stack;       // A pointer to an array that holds the contents.
};
\end{verbatim}

To define a template, we prepend the keyword {\tt template} to
the class definition, and we put the parameterized type for the
template in angle brackets.  If we need to parameterize the implementation
with two or more types, it works just like an argument list:
{\tt template <class T, class S>}.  We can use the type parameters
elsewhere in the definition, just like they were normal types.

When we provide the implementation for each of the member functions
in the class, we also have to declare them as templates, and again,
once we do that, we can use the type parameters just like normal types:

\begin{verbatim}
     // template version of Stack::Stack
template <class T> 
Stack<T>::Stack(int sz) {
    size = sz;
    top = 0;
    stack = new T[size];   // Let's get an array of type T
}

     // template version of Stack::Push
template <class T> 
void
Stack<T>::Push(T value) {
    ASSERT(!Full());
    stack[top++] = value;
}
\end{verbatim}

Creating an object of a template class is similar to creating
a normal object:

\begin{verbatim}
void
test() {
    Stack<int> s1(17);
    Stack<char> *s2 = new Stack<char>(23);

    s1.Push(5);
    s2->Push('z');
    delete s2;
}
\end{verbatim}

Everything operates as if we defined two classes, one
called {\tt Stack<int>} -- a stack of integers, and one
called {\tt Stack<char>} -- a stack of characters.
{\tt s1} behaves just like an instance of the first;
{\tt s2} behaves just like an instance of the second.
In fact, that is exactly how templates are typically implemented --
you get a complete {\em copy} of the code for the template
for each different instantiated type. In the above example,
we'd get one copy of the code for {\tt ints} and one copy for {\tt chars}.

So what's wrong with templates?  You've all been taught to make
your code modular so that it can be re-usable, so {\em everything}
should be a template, right?  Wrong.  

The principal problem with templates is that they can be {\em very} 
difficult to debug -- templates are easy to use if they work, but 
finding a bug in them can be difficult. In part this is because 
current generation C++ debuggers don't really understand templates 
very well.  Nevertheless, it is easier to debug a template than
two nearly identical implementations that differ only in their types.

So the best advice is -- don't make a class into a template
unless there really is a near term use for the template. And if you
do need to implement a template, implement and debug a non-template
version first.  Once that is working, it won't be hard to convert
it to a template.  Then all you have to worry about code
explosion -- e.g., your program's object code is now megabytes
because of the 15 copies of the hash table/list/... routines, one for 
each kind of thing you want to put in a hash table/list/...
(Remember, you have an unhelpful compiler!)

\section{Features To Avoid Like the Plague}

Despite the length of this note, there are numerous
features in C++ that I haven't explained.  I'm sure each feature
has its advocates, but despite programming in C and C++ for over 15 
years, I haven't found a compelling reason to use them in any code
that I've written (outside of a programming language class!) 

Indeed, there is a compelling reason to avoid using these features -- they are 
easy to misuse, resulting in programs that are harder to read and understand
instead of easier to understand.  In most cases, the features are also 
redundant -- there are other ways of accomplishing the same end.  Why have
two ways of doing the same thing?  Why not stick with the simpler one?

I do not use any of the following features in Nachos.  
If you use them, {\it caveat hacker}.

\begin{enumerate}

\item {\bf Multiple inheritance.}  It is possible in C++ to define
a class as inheriting behavior from multiple classes (for instance,
a dog is both an animal and a furry thing).  But if programs
using single inheritance can be difficult to untangle, programs
with multiple inheritance can get really confusing.

\item {\bf References.}  Reference variables are rather hard to
understand in general; they play the same role as pointers, with
slightly different syntax (unfortunately, I'm not joking!) 
Their most common use is to declare some parameters to a function 
as {\it reference parameters}, as in Pascal.  A call-by-reference 
parameter can be modified by the calling function, without the callee 
having to pass a pointer.  The effect is dhat p!rametgrs look ,to the ca,ler)`like they are called "y value (qnD theòenore caj't change),!
but in nact0can be transpar%.tly modyfiet "y 4hu called bu.ction.
Mâvioõsly, tiis can be a$soupcg of obscõòe bugs, not to men4ion
phat the semanuios of veferences in0C)+ are i. Generál not oböious®

\item {\rf OpeRaôor ovgrloading.}! C++ mets yïu redefile the meanings
of theopårat/rs (sucH cs"{\tt ;} and \vebb+>>+) foú class0objebts.Thic is dangErows at beqtp(&exac4|y hikh!implemujtatiOl of '+'!dïes
this!refer to?") and w`En used in non-intu)tive ways,(a
source of great confurion,0madå worse by the fact that C++ do%s 
impliãit typ% c/nvebsion, wh)ch c`n affmãt whhch operatoris invocud.  WnFkrtunatedy, C+¯'s K?O facilitiesmake he`v} use oæ operador oferl/áding and òeferencas, so you
can't complepuly escape tjEm, jut think ôwige before yo5 reeeFine
'+' do muan ``cncatd.atg ôhese twO surings''.

\item {\bf Functioj overloAding.g (You Ãan alóo define dic/esent fenctigns
hn a cLasc!with the same name but diffmre.t ar'uoent |}pE3.  Tlis ir also
eangerous (smnce )t's eawY to slép uð`and2wet the uniftunle$ v%rsion9, 
anl we nevEr use iu.  Wg Will alóo avoi` using äefcult a`guments!(for thd
sema reaskn).  Note thaô`ip can je a good ida to use"the same name fït 
functions i~ diæfårent clasóes- prov©del they usd dhe sa}eJavguments and!b%hare the same way0-- a2good dxamplg of thi is(That 
mnst Náchns objects have a {\tt Prift()}!methof.

Üitem {Xbg Staf¤ard tempdate licrAry.} An aNSI sdaNdard has eíe2gEd bor a
libr!òy /f roõ4ines iep¬ementing suah things as lisTs, hekhPTable{$
etc,¬ c!l<åd the staf$ard template lmbsary  Using such a library
should mAke programming mõch simplez!if the daua structure you need
i3`already pòovided in the library,  Alas, t`es6`ndcrd üemrlaTm
lib2cpy ðsqhes thÅ envelopå of mefem K++, and so virtually no
compIleps (inclwding g+#) caN support it tod!{.  Not to(ienpi/n that 
it usms (big surprise!i regerances,0o`era~or overloading, ad 
funãtion overloading.
\item k\bf Exceptions.| Tyere are two wayó to rfturn ao$mvror frOm
a"proc`dere.  kne`is simple ­= just dmfIne |há p2ocedupe to reTur~
an error cgde if it isn't¤a"lu to do it#s hg`. $FoR exam0le*
the rtaneasd lébrary routinE {\tt malloc} return{ NULL if t(ere is oo avaimable memkry. `However,`lots f programmess !re lazy and 
don't check erroz codes.  So!uher&s"the sol5tinn?  Yot might tiifk 
it wo}dä fe t/ gåt progpemeers vho aren'T lazy, bur no- the B++ skludion 
a3 dï Ad$ a rrográmmijg l`nguQge cïnrtruct! !A proaedure can
3eturn an esror by `ariying al(eYã%ptmoî'' whichevfectévely
causes a {^tt goDo} back up th% dxec4tion sd`ck to phe lasõ
place ôhe progra=ler 0õt an exception hannler.  You would toiNkthis0is too biz!rre to be true& jut!unfoxtunately,
I'm&not making ôiS vp.

Lene{enuieráte}

×hilm(I'm0gt iv, tHere are a numbar oG0f%adures nf B(that you$!ìsn*s(o}lä avoid( begause0they%lead to bugs and íace0}our cod} less ea3y
tg umdeóstand.  Seå Oaguire's$"Writéng Soli$ CoDåb for a more complete
discusshon`of thks issUe.  Qll of#thes% f%atures are leÇad$C;
what'q legal isj't nmcessarily god.

\begkj{enumerape}Mitem Poilter yrithmåtic.  unaway pointers abe ` prancipal {ourcea
of hard-ôo-Fhnd bugs in"C `tograms( because the sympuom mf thhó hippeningZcan`beàmaneled data strustures@)n a cï}plepely `ifdereNt part /f t`e 0roGram.DepEnding On$exictlz which objacts Are allocated on the heap in 7hych 
orfer, pOinter(bugs can appeav and disaprear$ óeemingli at random.
For0example, ;\tp qpéntf} 3oiåtimmq alhoãades mamory on the heap,
wèécH`san change t`a addre{ses returned by all fetuze calls to {\|t new}.
Thus,0adding é`{\td prindf} san change"thIngs sO vHat a qointer
which used to (By Heppunstance+ mangle a criticA, dqta strtcture
)quch aó phu middle of a threcd's exe#ution stakk), now overwvites memory 
tiet$may not even(be uced.

Phe0best way to aVoil runqway pointe2s ks (no sõrprise) to be 
{\Em ver{} careful whdï usine pointers  Ilstdad od iterating
thsoufh`an Array wath pïinder ap)thmmtic, use a saparate indåh  wariable a.d assert ôHat tle(index iS never larger ôhan |he size
æ the Array.  Optimizing compiluss har% fotten very0gmog, s_ that the
geöerated Machine code ys likely uO fe(the same in ekvhmr cqse.
Ev%n if you pon't Use po).ter av)Thme|ic, it/s stidl aas}+(easy is jid in this context!) t/ hava a~ off-by-one errror 
that causes your!pro'ra- to svEp b}onl0theàmnD of an!#rrey.
How lo you féx tjis?" Defina0e class tg contayn ôhd apray	;\em ald its lelgtj}; befOrm al|kwino anY$cccmss!to the arsay,&ygu cqn then cèeck whether the`accEss is le÷al0or(mn erroz.

\item CasT{ from intewers to qointers a~d bacë.  Aîother snu:ce
of runãva} pinte2s is that K qnd C++ ãllow you to convert
integers to pinôers, aneback again.  Leedle3s uo!say< using a 
rqndWi integer talue as a pointer is likely!|o rfsult in enpredictable
symptomsôhát vhll bE(vury hard to trqck down
Kn additiol, on b/me 64 jit íachanes, such as the Alàhá, iT yw
no longez uhe0Case ~hcÔ uhe sire of an integur ir the wam% as thG
ôhe size of e pomntez. `If you car4 båpween poInters aNd integeró,
You are al3/ riting hIghly non-prta"le coäe

\iteí Uscng$bIt shift in p,aka oæ a multiply"orèdivide.
Tjis is a slarivy0aósud.  If iou areàdoang !rithmetic, use
azhthmetib operatrs; if yot Ard ding bit ma~i0ulatioo,
use ritwise gpeRatoRs.  Éf I am tr)ing to mUlt)ply b9 , which is easiez do ulDeRwtand¬!y|tv x << 3m or {\tt x ª 8}?  In the 70's,!
wien C"was being detelopedì the Vormeò would yield mgre edficjent&
machijd kodu, but todqy7s aompijers guNeráte ô¨m same code in both
Cases,as¯ rea$Aâklit} should be your`pzimary ãoncern.

|item(Assignognt insidm conDitional." Many ðZogrsmmdrs have the attitude
that simplicity e±uals savinw as m ny kexstrokes as!tosaibìe®
Thu resUlt Can be to`h`de(bugs tjat would oth}rwIse be obvimus®
Bor exaíple:

\bewi~{vevba5im}    if (x = y) û
  !   /.ª
\end{vdrbatim}
Was thd yntenô really \tt0X == y? (Aftep !lll it's pretpy(ee{y
to!mksta+enli leave0off tha extra equals sign.  By nevur using
assignment wIthin a co~diti/n`l, {ïu can tell by coDe inspeãtéon
uhether`you§öu made0á mistake.

Xitem Using {\tt \#define} when you coulD use({Ütt Enumý.
When a 6ar)able caj hold one0of a!sla,l(.umber ïf values"
the`original C practice was D+ use {\tt(\#definm| to sEt up 
symbolic oames fob e`ch of thm v!lu}s. s\tt Gnum} does this 
kN e type-scfe(way -- at allows the gomqilur to veRIf;|hat the raridbl% is only assignef one of the ånumer`tet$valwes,:and!îone otjgp,  Again, the qdfantage is to eliminate a cl`ss oferrors from your program, mao)ng it qwicker to debug.
\end{enumm2ate}
\lewpage
\section{Styl% Guideliîms

E~en if yïu okllow the ap`roach!I've outlinud a#îvA, it is sT)ll
ac!easy to write unreadab,e and!e.debuggablm code$in C+* as it
is in C,bane perhApq easi%v. civen(the more `owarful"fectures tèe
langu`ge proVides. $F/ò tHe Nachns projecr. and in gEþeral, we suGgest 
you adherå to the gollkwing guideli~es (and&üelm us áf you aatch ôs 
bòeaking them):

\baein{enuleret¥}J
\itgm Wïrds$in a name are separated SmaìLTclk-3tyle (i.e/,"capital
letters at the starô!ob each new word).  Anl cdass nqmer"and melber
ftnctaon n`ids bdgin"wh4h e$capital lettez® except for member
vunctmo.s ov the"äorm {\tt"getÓometh)ng()} and {\dt setSomething8)}l
uhere {\tt 3omEthing} ir a daua element Nf The cLi3s$(me., eccessor
functions).  Note tjat you wou|a wa~t to p2ovyde sech functykns mnÌy
when the d`la shmuld be ~isible to the muuside world,`but you want to
borcå"all accesseó to go throuch one functioî.  Tèis is ftel!a good
ifeà¬ qinbe y/u might at smee la|er teme deciäe$to compUte tbe data
iosteaf nf storingàit, for example.

]iteo Ald gìMbal functions should gd!capitalized,
except f/r {]t4 máijm an` librari
ftncti/ns, which aRe {ept nower-case fïr hatkri#al z}ason3.

\itee Minimize uhe use of global ^abiables.  IF you &ind your3elf
using0a lot f ti%m, try and gboup 3ome toegthEr in a class in a
natur!l w!y"or p`s3 txem as arcumenvs to thm funcvions!that need the-
if you caj.
\item Lknmmize tae u3e!ïf global functi'ns (as npposet po mmmbev
dmnctiofs),  If you w"ite a fõfction that operates on rome(objekt,
c/nsidr"Maiing%ht i íemb'r function of pha4 gbject.
\éte- For ewery cjass op set of$rålated c|ásces¬"craatg a`{aparate
{\tt".h} fIlE end Y\tt .cc}(filg Tje {]tp .h} vale acts as the({^itKinterface} tm the class, anf the {\4T .cc} file!Ac|S as the[\it ilplemenTation} )a giVen$k\tt .#cu fYle rhould {Ttt )Nclude I|gs
pespecdivu qTtt$.h} file).  If uséng a(xarticehar¡{\ut .h} fyle requipes
another {Ütt(.h} fime to fe ifcÄuded *e.g., {Ttt`synch.h= nee`s
cnasC definitions$froi {\tô tlread.h}© you should inãlude 4he$depeldenCy
in ôhe {\t4 .h} &yle¬ so thát rhg user kf yur`cldss toeón/d have to 
track $own all tme dupandeocies hkmself.  
Uo prope#t agaynct meltiPne iocluséon, brabke|`uach ;Lxt .H}
fine wi|n soíethéng like:\begin{varbatia}'ifndef CTACK_I
#define T@Co_H

cliss tack { ... };

#enfiv
\eod{verbctim}
Somgôimes thió wiLl oot âe elou§l, and yt will háve k ciscudar
dåpenden+yn `Dor example, ùou might (áve a {]Dt .h} file that
uses a definition from one!{\tt .h} file but also dedinew!soídthinW
jgeled by%tlat {\tt .h} file.  In this Sace, you!hll have to do 
somahang ad-hoc&  One thing tm bealize i{`that yOu don't al7ays
have to completelù defiou a`class beFbe at is used.  If"you
only use e poaNter t`class {\tt Wtack} aêä dg ~ot accecs any
oember Functions$or data from the class, yo} can write, in lieu kn iîcluding {tt staãj*l}:
\begin{~erb`tim}
c|ess Stqck;
ÜEnd{verbatim}This will uell t`e coepyler all it
needs to$know to dEal with the pkintEr.  In a gew0caSes th)s`won'v work,
and yoe@will!have to move stuff around or altmr xo÷r defynitions.

\itum Usg û\4t ASSERT} steteleFts liâerally to gheCi t(at your prograiis behaving àroperly*  An assertion is i"condidiïn tHat if
FAÌSE {ignhdies$that thmre is a bug in thahproera-;
{\tt ASSERTm te3ts qn expression ajd abirts kg the cooditéof!ir
filse.  Wg used {\tt QSsERT} abov% in {\tt Stask::Push()} to chEck 
thát the stac+ wasn't full. Txe idea is`to catah errors ac"dqrlyau pnrsmble, wHaN Thma aze easier eo locate, instEad of waiting!tftin 
thgra is a uSer-tisibme symptom of the erzor )cucH as a segmenuatimn 
fiult, after oemopy¢ha{ båen trashed!by a zÏgue pointer)&

Assurviïn{ are"particuLarli qceful at tje beciNningS and enes oV`
procedures, t cheãk that`tim pcïcedure was called wiuj(the òight 
arguments, and that the procedure `kd whet!it is svdposed tg.
FoR example, a| uie feginning of Disv::Inser4' you(cound asserv"that 
the item bEinç ynsgrted iqnt alreadY /n4thå nist, and at |he end oftHe"pzoaedure, you kould assert thaw the i4em is now oæ the list.
JIf speED is`a concgr~, A_SERTs can âe definet to lake the check*il the debug varsion of your program, and to"be a nk-mp {n the4production
version.  BuT$many peop|e run witi ASSERTs enacled(evan )n vrotucdiol.

\ite- WritE a module te3t fob every modula in your proGrai.
Many trowrammErs havå"tje notéoî"tlat vesting bodd means running
the Entire program on wome salple0iopux; )æ it doísn't cra3, thad 
means )t'c workiîg. right?  Wòong.  [ou xave no way of inowiog
hou muCh cndg was eøergisgd`for thm tgst.  Ìet me urge`yoe"tk
"e!methoeical about |E{tin'.  Before you `ut0a new moduldijto a bigger sysôem- ecke surå th% module works$as advertiset 
fy Tesdi.g id0staoìadone.  If yo} do thiq for`evdry eotule< then when y/} put"thm mgduleS toçether, iostead(mæ s\EM hoping}
that ewerùthi~g widl work, ye will {\ee`know} iô will work.

Perhapr more!importan|ly, molu,eátests provkäe an o0portuniti
4o find as many bugs as qossibld il a |ocani~ed contåxtn  
Whych is e`sier: fénding a bug in$a 100 linedprogram, or`in0a *±000 |Ine pzogram?

\eNd{enumerate}

\section{Compiling and De`uggilg}

The0Makefi|eS we wjll give ùou works only whth t`e _NU wårsin of
make, called ``gmake&7.  You may!wantpo put abalias(mae cmake'' in ynur .cwlrc"fil%.

YOu s`/uLd uqe!{\bF gdb}(tm debug yuv$progvam ra|her öhán {\bf dcx.
D"x doe{n't!{n?w how to deciphgraC++(names, so!you will se% fõnction
nemes like \verb+RunW^9SchedulepP6T(òead«.

On ôhu p`er"handl in GDB"but not DBH)7Hen`ygu"do a`stack facktracu
whe. if a forkgd threcd (in (omewþrk"1©, ater prin|inc out tneJcorrec4 frames at the top on the stack, phe(deb5ggÅr will óom%times
'o into ! loop printi.g the¤lower¥most fzAm% ({\öt \h|eadRooT} , aNd 
yku hava vn type control-C when it saùs ``morm?g'&  If$yOu unDerstand
assembdy languagD anD cal fix tiis, pÌease let -e!know.

\section{xample: A Sdáck`of Io|ugevs}

We&vE prgvided the comðlet%, workkn' codt f+r(|je stask"exampme. !Yoq shouldraad throõgh it and pL!h around with!it to maká sure0yo} undersôanä
the`f%aturås of0C++ describel mn tiis P`per.
To compile The cimple quico test, tipe {\tt$meke alì} --
this will compilm`the siMpla ótacc 4es4 ({\t= stack,cc}©, 
the inhErIved sTasj test!({\tt inheritstack.Ãcu). and
the template versio~ of qtacks ({Xtt ôemplatestack.cc}).

^cection{MpiloguE}*
I/ve avgqgd if thiw no4e piat }ou should avoId using ceRtain C++ 
ane  feat5res.  But yoe'rM prob`"li thinking I must bm leaving(
something out -- if óoleone put the
fe!ture in the language, tlere musl bepa goo` r%asmn,0rigxd  I belimve tlát
åv%rx programmer shouLD stribe to wbyte kode whosm$behavi?r wOulD be
kmoe`iately mrv)oew to(k reader;
if }ou `a~d youvseLf wrmting cçde txat woald requaâe some'ne readingh4h% cod%
tm uhumb tirough a manuAl in order ôo understand it, you are$almost cõrtainly
bdhng way"too subtle.  Thaze's prbabl} a muah simPìer qld mora`obtiousway to acgomplisi tie rqme end., Maibu phe!cofe uill be a hittìealo/ger
thbt!Way¨
but in the peal"wor,d,8it/wpwhather the(code`workó1ane(Hkw óimple it i{ for
somemj% dlse!to modify, thav mavTors a lgle lot -ose |haN0how many
characteòc you had to type.

A filál$48oug`t to reme-ber:*\beGin{quota}
``There qre two w xs`of constructing a software designz onm way is uo
dake iô(so simple that theRm are {Tem(obviously} no defickencies ind
thu other way ms to make it so!cmmplicauad that t(erm ira no {\gm
obviour} DeniCiåjcie3®'' \ \Hbox{} \hfill C. A.$R. Hoare, ``Thm Empewor's
Old ÃloTheg''l CAM0Fmb.`19<1JÜaîd{quota}

\secpio~{Furthår Re`ding}

\bewin{itdoiúe}
\ktem[] ^amms(coxlien, ``Adva~ceh Ã++'', Addisnm-Ömsey.
This book8is only for ex`erts, bu| 	t has som% gmod ideas i~ it,
óo keep$ét"in`i)nd once yo5'vd bÅen prïgrammang in G++ for a!vew"years.
Litem[] Êames Oowmiîg.  ``The Java Language.''  Onjine at``http:'oj`va.sõn.com-''  Java is a {afe subsut of C++. (It's main 
apPlicauion és the óafe extensionaof Web broWseRs ây`allowing 
yot Fo downlgad JaVa Code&as partof clycki~c on a lilk to 
inperxrev an$ dysplay th% äïCumend.  Safety is ke} lara, wi~ge 
a&ter all, you dkn'T want to click n a WeB ìino and haöe 
ht dowlload #ode thatpwmll crash ykur$browser. (Jcva was degine` 
independentìy of tyhs documen}, but hnterespingly- it enforcew a 
very3similar style (bkr examtle, no m}ltIple"inhårit!nc%!andno op%vator vurlo`ding)*

\iteu[] C. .R. Hoare, `ptxe$Emqeror's Old$Cloôhe{.''
{\em Sommunications of the ACLm Vol. 2t, Nï. 2, Febpuary 1980,
pp. /5-93.  Tïny$Hoa%'s Turing Auard le#twre.$°How do you build 
sontware thaT reálly workr  Attitudç is averythhng =, yMu neel*a h%althy 2Espect!fo2 how hard it is to buiLd vorci~g coftware. 
It`méght seem that addding this wh)z-bang feattre ks only apa small iatt%z of0code'', but that's$thd patH to ìate, buggy
pro,wcts that don't$work.

\item[ Brian Kdrniçhan and Dunnis RiÔkhke, ``The!c Progr`íméng Laoouage'',
Preotice-H!,l.  The kriginal C(bkok -) aávery easp read.  BuT(t`elaoguage haó evoìöed since it wis first0designed, and vLiw book dmusn'|desaribe `hd of C'{ newdst feadures/  ut stinl pèe bm3t ðlace for
a bdg)noer to start, evEn"when2learnyne «+.

\itum[] Stgve Mcfuirg, ``Writing Solyd Cnd%'', Microsofv Pr%ss.
How!po wri|e bug=free$soætwaru; É thi~k thks!shmuld be required 
readingbfor all softwarm engmîeers. `ÔHis really {\e- Wkll} chqn'e 
yoUr liFe -- if yoq don'T follow`the pçbmmmendauhons in this book, 
you'l| pro"acly"ldv%r wpitE!cole that gompleuely worjs¬ anD You/ll
spend qour entiru life strõggling with hard to find Bugs.( Ther% is0a `etter vay!" Contrary to the proçramm)ng LaNguage tùpew, 
this doesn't involve proving the correctness of your programs, whatever
that means.  Instead, Maguire has a set of practical engineering 
solutions to writing solid code.

\item[] Steve Maguire, ``Debugging the Development Process'', Microsoft Press.
Maguire's follow up book on how to lead an effective team, and
by the way, how to be an effective engineer.  Maguire's background is 
that he is a turnaround artist for Microsoft -- he gets assigned to 
floundering teams, and figures out how to make them effective.
After you've pulled a few all-nighters to get that last bug out
of your course project, you're probably wondering why in heck you're
studying computer science anyway.  This book will explain how
to write programs that work, {\em and} still have a life!

\item[] Scott Meyers, ``Effective C++''.  This book describes how
50 easy ways to make mistakes C++; if you avoid these, you will 
be a lot more likely to write C++ code that works.

\item[] Bjarne Stroustrup, ``The C++ Programming Language'', Addison-Wesley.
This should be the definite reference manual, but it isn't.
You probably thought I was joking when I said the C++ language was
continually evolving.  I bought the second edition of this
book three years ago, and it is already out of date.
Fortunately, it's still OK for the subset of C++ that I use.
\end{itemize}

\end{document}
